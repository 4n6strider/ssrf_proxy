{"name":"SSRF Proxy","tagline":"SSRF Proxy facilitates tunneling HTTP communications through servers vulnerable to SSRF.","body":"```\r\n               ___                         \r\n   ___ ___ ___|  _|    ___ ___ ___ _ _ _ _ \r\n  |_ -|_ -|  _|  _|   | . |  _| . |_'_| | |\r\n  |___|___|_| |_|     |  _|_| |___|_,_|_  |\r\n                      |_|             |___|\r\n\r\n               SSRF Proxy v0.0.1\r\n    https://github.com/bcoles/ssrf_proxy\r\n```\r\n\r\n# SSRF Proxy\r\n\r\n## Description\r\n\r\nSSRF Proxy is a multi-threaded HTTP proxy server designed to\r\ntunnel client HTTP traffic through HTTP servers vulnerable\r\nto HTTP Server-Side Request Forgery (SSRF).\r\n\r\nOnce configured, SSRF Proxy attempts to format client HTTP\r\nrequests appropriately for the vulnerable server. Likewise,\r\nthe server's response is parsed and formatted for the client.\r\n\r\nBy correctly formatting the client request and stripping\r\nunwanted junk from the response it is possible to use\r\nSSRF Proxy as a HTTP proxy for web browsers and scanning\r\ntools such as sqlmap and nikto.\r\n\r\nSSRF Proxy also assists with leveraging blind SSRF\r\nvulnerabilities to perform time-based attacks, such\r\nas blind time-based SQL injection with sqlmap.\r\n\r\nRefer to the wiki for more information:\r\nhttps://github.com/bcoles/ssrf_proxy/wiki\r\n\r\n\r\n## Requirements\r\n\r\nRuby\r\n\r\nRuby Gems:\r\n- celluloid-io\r\n- webrick\r\n- logger\r\n- colorize\r\n- ipaddress\r\n\r\n\r\n## Installation\r\n\r\n```\r\n$ gem install ssrf_proxy\r\n```\r\n\r\n## Usage (command line)\r\n\r\n```\r\n$ ssrf-proxy -h\r\n\r\n_______________________________________________\r\n                ___                            \r\n    ___ ___ ___|  _|    ___ ___ ___ _ _ _ _    \r\n   |_ -|_ -|  _|  _|   | . |  _| . |_'_| | |   \r\n   |___|___|_| |_|     |  _|_| |___|_,_|_  |   \r\n                       |_|             |___|   \r\n\r\n                SSRF Proxy v0.0.1\r\n      https://github.com/bcoles/ssrf_proxy\r\n\r\n_______________________________________________\r\n\r\nUsage:   ssrf-proxy [options] -u <SSRF URL>\r\nExample: ssrf-proxy -u http://target/?url=xxURLxx\r\nOptions:\r\n\r\n   -h, --help             Help\r\n   -v, --verbose          Verbose output\r\n   -d, --debug            Debugging output\r\n\r\n  Server options:\r\n   -p, --port=PORT        Listen port (Default: 8081)\r\n       --interface=IP     Listen interface (Default: 127.0.0.1)\r\n       --proxy=PROXY      Upstream HTTP proxy\r\n\r\n  SSRF request options:\r\n   -u, --url=URL          SSRF URL with 'xxURLxx' placeholder\r\n       --method=METHOD    HTTP method (GET/POST/HEAD) (Default: GET)\r\n       --post-data=DATA   HTTP post data\r\n       --cookie=COOKIE    HTTP cookies (separated by ';')\r\n       --user-agent=AGENT HTTP user-agent (Default: Mozilla/5.0)\r\n       --timeout=SECONDS  Connection timeout in seconds (Default: 10)\r\n       --ip-encoding=MODE Encode IP address for blacklist evasion.\r\n                          (Modes: int, ipv6, oct, hex) (Default: none)\r\n       --rules=RULES      Rules for parsing client request for xxURLxx\r\n                          (separated by ',') (Default: none)\r\n\r\n  HTTP response modification:\r\n       --match=REGEX      Regex to match response body content.\r\n                          (Default: \\A(.+)\\z)\r\n       --strip=HEADERS    Headers to remove from the response.\r\n                          (separated by ',') (Default: none)\r\n       --guess-status     Replaces response status code and message\r\n                          headers (determined by common strings in the\r\n                          response body, such as 404 Not Found.)\r\n       --guess-mime       Replaces response content-type header with the\r\n                          appropriate mime type (determined by the file\r\n                          extension of the requested resource.)\r\n\r\n  Client request modification:\r\n       --forward-cookies  Forward client HTTP cookies through proxy to\r\n                          SSRF server.\r\n       --body-to-uri      Convert POST parameters to GET parameters.\r\n       --auth-to-uri      Move HTTP basic authentication credentials\r\n                          to URI. (Example: http://[user:pass]@host/)\r\n\r\n```\r\n\r\n\r\n## Usage (ruby)\r\n\r\nFirst, create a new SSRFProxy::HTTP object:\r\n\r\n```\r\n  # SSRF URL with 'xxURLxx' placeholder\r\n  url = 'http://example.local/index.php?url=xxURLxx'\r\n  # options\r\n  opts = {\r\n    'proxy'          => \"\",\r\n    'method'         => \"GET\",\r\n    'post_data'      => \"\",\r\n    'rules'          => \"\",\r\n    'ip_encoding'    => \"\",\r\n    'match'          => \"\\\\A(.+)\\\\z\",\r\n    'strip'          => \"\",\r\n    'guess_mime'     => false,\r\n    'guess_status'   => false,\r\n    'forward_cookies'=> false,\r\n    'body_to_uri'    => false,\r\n    'auth_to_uri'    => false,\r\n    'cookie'         => \"\",\r\n    'timeout'        => 10,\r\n    'user_agent'     => \"Mozilla/5.0\"\r\n  }\r\n  # create SSRFProxy::HTTP object\r\n  ssrf = SSRFProxy::HTTP.new(url, opts)\r\n  # set log level\r\n  ssrf.logger.level = Logger::DEBUG\r\n```\r\n\r\nThen send HTTP requests via the SSRF:\r\n\r\n```\r\n  # fetch http://127.0.0.1/ via SSRF by String\r\n  uri = 'http://127.0.0.1/'\r\n  ssrf.send_uri(uri)\r\n\r\n\r\n  # fetch http://127.0.0.1/ via SSRF by URI\r\n  uri = URI::parse('http://127.0.0.1/')\r\n  ssrf.send_uri(uri)\r\n\r\n\r\n  # fetch http://127.0.0.1/ via SSRF using a raw HTTP request\r\n  http = \"GET http://127.0.0.1/ HTTP/1.1\\n\\n\"\r\n  ssrf.send_request(http)\r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}