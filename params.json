{
  "name": "SSRF Proxy",
  "tagline": "SSRF Proxy facilitates tunneling HTTP communications through servers vulnerable to SSRF.",
  "body": "# SSRF Proxy\r\n\r\n<a href=\"https://github.com/bcoles/ssrf_proxy\" target=\"_blank\">\r\n  <img src=\"https://img.shields.io/badge/version-0.0.3-brightgreen.svg\"/>\r\n</a>\r\n<a href=\"https://travis-ci.org/bcoles-ci/ssrf_proxy\" target=\"_blank\">\r\n  <img src=\"https://api.travis-ci.org/bcoles-ci/ssrf_proxy.svg?branch=master\"/>\r\n</a>\r\n<a href=\"https://www.versioneye.com/ruby/ssrf_proxy/\" target=\"_blank\">\r\n  <img src=\"https://img.shields.io/versioneye/d/ruby/ssrf_proxy.svg\"/>\r\n</a>\r\n<a href=\"https://hakiri.io/github/bcoles-ci/ssrf_proxy/master/\" target=\"_blank\">\r\n  <img src=\"https://hakiri.io/github/bcoles-ci/ssrf_proxy/master.svg\"/>\r\n</a>\r\n<a href=\"https://codeclimate.com/github/bcoles/ssrf_proxy\" target=\"_blank\">\r\n  <img src=\"https://codeclimate.com/github/bcoles/ssrf_proxy/badges/gpa.svg\"/>\r\n</a>\r\n<a href=\"https://coveralls.io/github/bcoles-ci/ssrf_proxy?branch=master\" target=\"_blank\">\r\n  <img src=\"https://coveralls.io/repos/github/bcoles-ci/ssrf_proxy/badge.svg?branch=master\"/>\r\n</a>\r\n<a href=\"https://inch-ci.org/github/bcoles/ssrf_proxy\" target=\"_blank\">\r\n  <img src=\"https://inch-ci.org/github/bcoles/ssrf_proxy.svg?branch=master\"/>\r\n</a>\r\n<a href=\"https://github.com/bcoles/ssrf_proxy/blob/master/LICENSE.md\" target=\"_blank\">\r\n  <img src=\"https://img.shields.io/badge/license-MIT-brightgreen.svg\"/>\r\n</a>\r\n\r\n**SSRF Proxy** is a multi-threaded HTTP proxy server designed\r\nto tunnel client HTTP traffic through HTTP servers vulnerable\r\nto HTTP Server-Side Request Forgery (SSRF).\r\n\r\nOnce configured, SSRF Proxy attempts to format client HTTP\r\nrequests appropriately for the vulnerable server. Likewise,\r\nthe server's response is parsed and formatted for the client.\r\n\r\nBy correctly formatting the client request and stripping\r\nunwanted junk from the response it is possible to use\r\nSSRF Proxy as a HTTP proxy for web browsers and scanning\r\ntools such as sqlmap and nikto.\r\n\r\nSSRF Proxy also assists with leveraging blind SSRF\r\nvulnerabilities to perform time-based attacks, such\r\nas blind time-based SQL injection with sqlmap.\r\n\r\n<table>\r\n  <tr>\r\n    <th>Version</th>\r\n    <td>0.0.3</td>\r\n  </tr>\r\n  <tr>\r\n    <th>Github</th>\r\n    <td>\r\n      <a href=\"https://github.com/bcoles/ssrf_proxy\">https://github.com/bcoles/ssrf_proxy</a>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <th>Wiki</th>\r\n    <td><a href=\"https://github.com/bcoles/ssrf_proxy/wiki\">https://github.com/bcoles/ssrf_proxy/wiki</a></td>\r\n  </tr>\r\n  <tr>\r\n    <th>Documentation</th>\r\n    <td>\r\n      <a href=\"http://www.rubydoc.info/github/bcoles/ssrf_proxy\" target=\"_blank\">http://www.rubydoc.info/github/bcoles/ssrf_proxy</a>\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <th>Author</th>\r\n    <td>Brendan Coles</td>\r\n  </tr>\r\n  <tr>\r\n    <th>Copyright</th>\r\n    <td>2015-2016 Brendan Coles</td>\r\n  </tr>\r\n  <tr>\r\n    <th>License</th>\r\n    <td>MIT - (see <a href=\"https://github.com/bcoles/ssrf_proxy/blob/master/LICENSE.md\">LICENSE.md</a> file)</td>\r\n  </tr>\r\n</table>\r\n\r\n\r\n## Requirements\r\n\r\nRuby 1.9.3 or newer\r\n\r\nRuby Gems:\r\n\r\n- celluloid-io\r\n- webrick\r\n- logger\r\n- colorize\r\n- ipaddress\r\n- base32\r\n- htmlentities\r\n- socksify\r\n\r\n## Installation\r\n\r\n```\r\n$ gem install ssrf_proxy\r\n```\r\n\r\n## Usage (command line)\r\n\r\n```\r\nUsage:   ssrf-proxy [options] -u <SSRF URL>\r\nExample: ssrf-proxy -u http://target/?url=xxURLxx\r\nOptions:\r\n\r\n   -h, --help             Help\r\n   -v, --verbose          Verbose output\r\n   -d, --debug            Debugging output\r\n\r\n  Server options:\r\n   -p, --port=PORT        Listen port (Default: 8081)\r\n       --interface=IP     Listen interface (Default: 127.0.0.1)\r\n\r\n  SSRF request options:\r\n   -u, --url=URL          SSRF URL with 'xxURLxx' placeholder\r\n       --method=METHOD    HTTP method (GET/HEAD/DELETE/POST/PUT)\r\n                          (Default: GET)\r\n       --post-data=DATA   HTTP post data\r\n       --cookie=COOKIE    HTTP cookies (separated by ';')\r\n       --user-agent=AGENT HTTP user-agent (Default: Mozilla/5.0)\r\n       --rules=RULES      Rules for parsing client request for xxURLxx\r\n                          (separated by ',') (Default: none)\r\n\r\n  SSRF connection options:\r\n       --proxy=PROXY      Use a proxy to connect to the server.\r\n                          (Supported proxies: http, https, socks)\r\n       --insecure         Skip server SSL certificate validation.\r\n       --timeout=SECONDS  Connection timeout in seconds (Default: 10)\r\n\r\n  HTTP response modification:\r\n       --match=REGEX      Regex to match response body content.\r\n                          (Default: \\A(.*)\\z)\r\n       --strip=HEADERS    Headers to remove from the response.\r\n                          (separated by ',') (Default: none)\r\n       --decode-html      Decode HTML entities in response body.\r\n       --guess-status     Replaces response status code and message\r\n                          headers (determined by common strings in the\r\n                          response body, such as 404 Not Found.)\r\n       --guess-mime       Replaces response content-type header with the\r\n                          appropriate mime type (determined by the file\r\n                          extension of the requested resource.)\r\n       --ask-password     Prompt for password on authentication failure.\r\n                          Adds a 'WWW-Authenticate' HTTP header to the\r\n                          response if the response code is 401.\r\n\r\n  Client request modification:\r\n       --forward-cookies  Forward client HTTP cookies through proxy to\r\n                          SSRF server.\r\n       --cookies-to-uri   Add client request cookies to URI query.\r\n       --body-to-uri      Add client request body to URI query.\r\n       --auth-to-uri      Use client request basic authentication\r\n                          credentials in request URI.\r\n       --ip-encoding=MODE Encode client request host IP address.\r\n                          (Modes: int, ipv6, oct, hex, dotted_hex)\r\n\r\n\r\n```\r\n\r\n\r\n## Usage (ruby)\r\n\r\nFirst, create a new SSRFProxy::HTTP object:\r\n\r\n```\r\n  # SSRF URL with 'xxURLxx' placeholder\r\n  url = 'http://example.local/index.php?url=xxURLxx'\r\n  # options\r\n  opts = {\r\n    'proxy'          => '',\r\n    'method'         => 'GET',\r\n    'post_data'      => '',\r\n    'rules'          => '',\r\n    'ip_encoding'    => '',\r\n    'match'          => \"\\\\A(.+)\\\\z\",\r\n    'strip'          => '',\r\n    'decode_html'    => false,\r\n    'guess_mime'     => false,\r\n    'guess_status'   => false,\r\n    'ask_password'   => false,\r\n    'forward_cookies'=> false,\r\n    'body_to_uri'    => false,\r\n    'auth_to_uri'    => false,\r\n    'cookies_to_uri' => false,\r\n    'cookie'         => '',\r\n    'timeout'        => 10,\r\n    'user_agent'     => 'Mozilla/5.0',\r\n    'insecure'       => false\r\n  }\r\n  # create SSRFProxy::HTTP object\r\n  ssrf = SSRFProxy::HTTP.new(url, opts)\r\n  # set log level (optional)\r\n  ssrf.logger.level = Logger::DEBUG\r\n```\r\n\r\nThen send HTTP requests via the SSRF:\r\n\r\n```\r\n  # fetch http://127.0.0.1/ via SSRF by String\r\n  uri = 'http://127.0.0.1/'\r\n  ssrf.send_uri(uri)\r\n\r\n\r\n  # fetch http://127.0.0.1/ via SSRF by URI\r\n  uri = URI.parse('http://127.0.0.1/')\r\n  ssrf.send_uri(uri)\r\n\r\n\r\n  # fetch http://127.0.0.1/ via SSRF using a raw HTTP request\r\n  http = \"GET http://127.0.0.1/ HTTP/1.1\\n\\n\"\r\n  ssrf.send_request(http)\r\n```\r\n\r\n## Documentation\r\n\r\nRefer to the wiki for more information and example usage:\r\nhttps://github.com/bcoles/ssrf_proxy/wiki\r\n\r\nRefer to RubyDoc for code documentation:\r\nhttp://www.rubydoc.info/github/bcoles/ssrf_proxy\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}